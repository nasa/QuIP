#include "quip_config.h"

#include <stdio.h>

#ifdef HAVE_STDLIB_H
#include <stdlib.h>	/* abs() */
#endif

#include "pacer.h"

/*
 * Here we borrow some code from another driver for a similar Computer
 * Boards product...
 *
 * The original SetPacerFreq had an board* arg, this has been changed
 * to take the desired freuqnecy (in Hz).
 */

/*
 * Copyright (C) 1995  Sam Moore, Warren Jasper
 * Copyright (C) 1995  Ricky Beam, Rob Cox
 * Copyright (C) 1996  Joerg Weule
 * All rights reserved.
 *
 * This software may be freely copied, modified, and redistributed
 * provided that this copyright notice is preserved on all copies.
 *
 * You may not distribute this software, in whole or in part, as part of
 * any commercial product without the express consent of the authors.
 *
 * There is no warranty or other guarantee of fitness of this software
 * for any purpose.  It is provided solely "as is".
 *
 */


/****************************************************************************
 *   Set Pacer Clock Frequency
 * 
 *   Description: 
 *       Set the counters so that the pacer clock runs at the
 *       desired frequency.  The frequency is generated by dividing
 *       down a 10 MHz clock, so all frequencies can not be generated.
 *       This routine calculated the divisor to generate a frequency
 *       as near as possible to the requested one.  It then calculates
 *       the real frequency and returns it .
 *
 * JBM modifications:  this is now a user-space function, we compute the dividers
 * and return them using the pointer args.
 *
 ****************************************************************************/

double SetPacerFreq( double desired_freq , unsigned short *c1p, unsigned short *c2p )
{
  unsigned short ctr1, ctr2;
  long desired_product;
  double actual_freq, error;

  /* divide 10Mhz by frequency */

  /* This assumes the board is set for 10Mhz -- RB */

  desired_product =  10000000.0 / desired_freq + 0.5;

  /*
     Now the job is to find two 16 bit numbers, that when multiplied
     together are approximately equal to desired_product.  Start by setting
     one of them, ctr1 to 2 (minimum settable value) and increment until
     the error is minimized and ctr2 is less than 32768.
     
     NOTE: In Mode 2, a value of 1 is illegal! Therefore, crt1 and crt2
     can never be 1.
     */

  ctr1 = desired_product / 32768;
  if ( ctr1 < 2 ) ctr1 = 2;
  ctr2 = desired_product / ctr1;
  error = abs(desired_product - ctr2*ctr1);

  while ( error && ctr1 < 32768  && ctr2 > 1 ) {
    ctr1++;
    ctr2 = desired_product / ctr1;
    error = abs(desired_product - ctr2*ctr1);
  }

  /* the frequency is prime, add 1 to it */

  if ( error ) {
    desired_product ++;
    ctr1 = desired_product / 32768;
    if ( ctr1 < 2 ) ctr1 = 2;
    ctr2 = desired_product / ctr1;
    error = abs(desired_product - ctr2*ctr1);

    while ( error  && ctr1 < 32768 && ctr2 > 1) {
      ctr1++;
      ctr2 = desired_product / ctr1;
      error = abs(desired_product - ctr2*ctr1);
    }
  }

  /* we can't have ctr2 equal to 1, or system hangs */

  if ( ctr2 == 1 ) {
    ctr2++;
    ctr1 /= 2;
  }

  actual_freq = 10000000.0/(ctr1*ctr2) ;

  *c1p = ctr1;
  *c2p = ctr2;
  return(actual_freq);

}

